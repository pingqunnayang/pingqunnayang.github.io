---
layout: post
title:  CSAPP学习笔记之机器代码
titlename:  CSAPP学习笔记之机器代码
date:  	2015-05-31 17:48:00  
category: 技术
tags: System Unix ISA
description:
---
<p style="text-indent: 2em">一直想整理下第一部分『程序结构和执行』的笔记，但是自己不知道如何下笔写，后来由于第三部分的IO、网络和并发本书介绍的不够详细，又跳到APUE上面去深入学习了，再次回来，发现自己对整个程序的结构和执行又有点陌生，虽然之前翻了好几遍，但是还是不知道blog如何来写，怎么从由粗到细的逐步往下深入写。</p>
<p style="text-indent: 2em">有时候做事也有同样的错误，总想把一切东西都准备好了，才敢开始动手，而当其中有一两项特别难下结论时，自己就陷入一个钻牛角尖的状态，慢慢把事情的其他方面都淡忘了，导致事情一直拖延。某一天因为技术问题回头看自己写的blog，发现看完后自己还是不能完全了解，虽然在写时候自己认为笔记写的很容易理解，会回忆起很多东西（惭愧）。后来根据blog再去翻书，再次看书后发现之前写的blog很烂，自己过几个月回来看都无法解决问题，更何况被别人看到，于是又对blog做了第二次修改，每次修改都是一次进步，也是对旧知识的重新认识和熟悉，尤其是那种你需要看很多遍的书，往往在看完一遍后，整理下思路写篇blog（再烂都要动手），待你看第二遍的时候，可以先看下自己的blog笔记，然后再看书，能发现自己blog的很多漏洞和错误，再次修改blog可以让自己印象更深。吐槽了好多，就是要行胜于言，开始写就是进步。
###1.1 程序编码
<p style="text-indent: 2em">计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理存储器、读写存储设备上的数据，以及利用网络通讯。当我们编写的C语言程序编码要在机器上运行时，必须经过下面几个步骤：

- 通过C`编译器`生成一个ASCII汇编语言文件。
- 通过`汇编器`生成一个可重定位的目标文件。
- 通过`链接器`生成一个可执行目标文件。

假如我们写一个C语言代码文件code .c，定义如下：

```c
 int accum = 0;
 int sum(int x,int y){
	int t = x + y;
	accum += t;
	return t;
 }
```

当使用GCC编译器编译后会产生一个汇编文件code.s，汇编文件包括下面几行：

```c
sum:
	pushl  %ebp
	movl   %esp,%ebp
	movl   12(%ebp),%eax
	addl   8(%ebp),%eax
	addl   %eax,accum
	popl   %ebp
	ret
```

上面每行代表一条机器指令，我们看到了一个全局变量accum的引用，这是因为编译器还不能确定这个变量会放到存储器的那个位置，当我们用汇编器对code.s进行汇编时，会生产二进制的目标文件，再用反汇编器解析代码如下（右边是注释）：

```c
##目标文件如下：
55	89	e5	8b	45	0c	03	45	08	01	05	00	00	00	00	5d	c3
##反编译器生成如下：
00000000 <sum>:
offset Bytes                        注释
	0:	55							pushl  %ebp
	1:	89	e5						movl   %esp,%ebp
	3:	8b	45	0c					movl   12(%ebp),%eax
	6:	03	45	08					addl   8(%ebp),%eax
	9:	01	05	00	00	00	00		addl   %eax,accum
	f:	5d							popl   %ebp
   10:	c3							ret
```

每行字节都代表一个操作，每个字节都可以唯一地解码成机器指令，如指令pushl  %ebp是以字节值55开头的。此目标文件还不能运行，它包含所有指令的二进制表示，但是还没有填入地址的全局值，通过链接器会生产可执行文件，代码序列如下：

```c
08048394 <sum>:
offset Bytes                           注释
80848394:	55							pushl  %ebp
80848395:	89	e5						movl   %esp,%ebp
80848397:	8b	45	0c					movl   12(%ebp),%eax
8084839a:	03	45	08					addl   8(%ebp),%eax
8084839d:	01	05	18	a0	04	08		addl   %eax,accum
808483a3:	5d							popl   %ebp
808483a4:	c3							ret
```

这段代码与上面代码完全一样，只是左边列出的地址不同，还有不同就是全局变量accum的地址变化了，在上面是0，现在是0x8041018。
<p style="text-indent: 2em">计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种尤为重要。第一种是机器级程序的格式和行为，定义为指令集体系结构（Instruction set architecture ISA）它定义了处理器的状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储地址是虚拟地址，如上面的OX8041018就是虚拟地址

###1.2 指令集合体系结构
<p style="text-indent: 2em">一个处理器支持的指令和指令的字节级编程称为它的指令集合体系结构（ISA），本文的指令都是IA32机器上的，IA32上的指令包括数据传送指令、算术和逻辑指令、条件和跳转指令、循环等。
####1.2.1 数据传送指令
数据传输指令是使用最频繁的指令，它将数据从一个位置复制到另外一个位置，下图列出一些重要的数据传输指令：

![Alt text](/public/img/technology/ISA-1.jpg)


<p style="text-indent: 2em">MOV类中的指令是将源操作数的值赋值到目的操作数中，源操作数指定的值可以是一个立即数，存储在寄存器中或者存储器中。目的操作数指定一个位置，要么一个寄存器要么是一个存储地址。IS32有一个限制`传送指令的两个操作数不能都指向存储器位置`。
操作数分三种类型：

-	立即数（immediate）：就是常数值，汇编中的书写格式是"\$"后面跟一个整数，例如：$-577、$0x1F。
-	存储器（memory）：它会根据计算出来的地址访问某个存储器位置，我们用M[Addr]表示对存储在存储器中从地址Addr开始的b个字节的引用。
-	寄存器（register）：它表示某个寄存器的内容，IA32处理器包含一组8个存储32位值的寄存器。见下图

![Alt text](/public/img/technology/ISA-2.png)

<p style="text-indent: 2em">字节操作可以独立地读或者写前4个寄存器的2个低位字节，在过程调用中，%eax、%ebx和%ecx被划分为调用者保存寄存器，而寄存器%ebx、%esi和%edi被划分为被调用者保存寄存器，最后两个%ebp、%esp保存着指向程序栈中重要的位置指针。

![Alt text](/public/img/technology/ISA-3.png)

上图中是多种不同的寻址模式，在了解了数据传输指令和操作数的类型以及操作数的格式后，我们可以拿上面的汇编指令做说明，算术和逻辑指令和传输指令大同小异，大家可以查看CSAPP的第三章。下面是一段代码和它的汇编代码：

```c
 int accum = 0;
 int sum(int x,int y){
	int t = x + y;
	accum += t;
	return t;
 }
 
sum:
	pushl  %ebp  // 入栈
	movl   %esp,%ebp  //上面两句涉及到过程调用栈的位置关系，后面会解释。
	/** 此句就是将M[%ebx +12]处的存储器值赋值给%eax，M[%ebx+12]
	 *处的值就是x，x为什么是在%ebx偏移12的位置，这个会在过程调用讲到。
	 */
	movl   12(%ebp),%eax  
	/** 添加操作，M[%ebx +8]是与的值，%eax现在存的是x的值，
	 *这句指令就是将x+y写入到	%eax中，这样%eax就存储了x+y的值 
	 */
	addl   8(%ebp),%eax
	addl   %eax,accum  //这句相当于accum += t;
	popl   %ebp  //出栈，和过程调用有关后面会说明。
	ret  //返回
```

第一条指令和倒数第二条指令操作可以将数据压入程序栈中，以及从程序栈中弹出数据，栈是向下增长的如下图：

![Alt text](/public/img/technology/ISA-4.png)

#### 1.2.2 过程调用
<p style="text-indent: 2em">一个过程调用包含将数据（以过程参数和返回值的形式）和控制代码的一部分传递到另一部分。为单个过程分配的那部分栈成为栈帧（stack frame）。下图是栈帧的通用结构，要了解栈帧需要先熟悉几个寄存器：
一个过程调用包含将数据（以过程参数和返回值的形式）和控制代码的一部分传递到另一部分。为单个过程分配的那部分栈成为栈帧（stack frame）。下图是栈帧的通用结构，要了解栈帧需要先熟悉几个寄存器：

- %ebp 帧指针
- %esp 栈指针
- %eip 程序计数器

栈指针可以移动，一直指向栈顶，而帧指针是作为相对位置，方便我们取值，因为栈指针会移动，所以不能用栈指针来取栈帧中的值。下图是栈帧的结构图：

![Alt text](/public/img/technology/ISA-5.png)

下面是支持过程调用和返回的指令

![Alt text](/public/img/technology/ISA-6.png)

call指令有一个目标，指明被调用过程起始的指令地址，它的效果是将返回地址入栈，并跳转到被调用过程的起始位置。ret指令从栈中弹出地址，跳转到这个位置。下面是一段调用函数的代码，caller方法中调用了函数swad_add，我们看下它的汇编代码结构。

```c
int swap_add(int *xp,int *yp){
	int x = *xp;
	int y = *yp;
	*xp = y;
	*yp = x
	return x+y;	
}

int caller(){
	int arg1 = 534;
	int arg2 = 1057;
	int sum = swap_add(&arg1,&arg2);
	int diff = arg1 - arg2;
	return sum*diff;
}
```

下图是caller的栈帧结构

![Alt text](/public/img/technology/ISA-7.png)

caller的栈帧包含局部变量arg1和arg2的存储，其位置相对于帧指针是-4和-8，下面是caller的汇编代码。

```c
caller:
	pushl 	%ebp				// 将%ebp的值保存到栈
	movl	%esp, %ebp	        // 将栈顶地址赋值给%ebp
	subl	$24, %esp			// 在栈上分配24个字节
	movl	$534, -4(%ebp)		// 将常数534赋值在栈相对位置
	movl	$1057, -8(%ebp)		// 将常数1057赋值在栈相对位置
	leal	-8(%ebp)，%eax      
	movl	%eax, 4(%esp)		// 将&arg2放在栈上
	leal	-4(%ebp), %eax
	movl 	%eax, (%esp)		// 将&arg1放在栈上
	call	swap_add			// 调用swad_add方法
```

调用call后，我们看到栈中压入了返回地址，然后跳入到swap_add的起始位置，swap_add编译过的代码分成3部分来解析：建立部分，初始化栈帧；主体部分是执行过程的实际计算；结束部分用来恢复栈的状态，已经过程返回。

```c
swap_add:
	pushl	%ebp			// 保存caller的%ebp到栈中，因为返回后caller还需要使用。
	movl	%esp, %ebp;		// 将%ebp指向栈顶
	pushl	%ebx			
```

函数swap_add需要使用到寄存器%ebp作为临时存储，因为%ebp是一个被调用者的保存寄存器。下面是主体代码：

```c
	movl	8(%ebp), %edx		
	movl	12(%ebp), %ecx
	movl	(%edx), %ebx
	movl	(%ecx), %eax
	movl	%eax, (%edx)
	movl	%ebx, (%ecx)
	addl	%ebx, %eax			// 添加将新值赋值给%eax作为返回
```

下面是swap_add的结束代码：

```c
	popl	%ebx		// 弹出%ebx
	popl	%ebp		// 弹出caller的%ebp，这就是复原caller函数
	ret					// ret弹出返回地址，并跳到这个位置
```

上面代码执行完了ret，控制就转回到了caller函数，下面是caller函数调用call之后的汇编代码。

```c
	movl	-4(%ebp), %edx  
 	subl	-8(%ebp), %edx  // arg1-arg2结果放入%edx
	imull	%edx,%eax		// 与swap_add的结果相乘
	level					// level作用是重置栈帧指针
	ret
```

从上面例子我们看到，我们在调用函数返回前，函数必须将栈恢复到原始条件，可以恢复所有的被调用者保存寄存器和%ebp，并且重置%esp使其指向返回地址。

### 1.3 指令执行步骤
<p style="text-indent: 2em">通常处理一条指令包含很多操作，将它们组织成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令，下面是各个阶段的描述：

- **取值**（fetch）：取值阶段从存储器读取指令字节，地址为程序计数器(pc)的值。从指令中抽取出指令指示符的字节的两个四位部分，称为icode（指令代码）和ifun（指令功能）。
- **译码**（decode）：译码阶段从寄存器文件读取最多两个操作数，得到值valA和/或valB。
- **执行**（execute）：在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据ifun的值），计算存储器引用的有效地址，要么增加或减小栈指针，得到值我们称为valE。
- **访存**（memory）：访存阶段可以将数据写入存储器，或者从存储器读取数据，读出的值为valM。
- **写回**（write back）：写回阶段最多可以写两个结果到寄存器文件。
- **更新PC**（PC update）：将PC设置成下一条指令的地址。

处理器无线循环，执行这些阶段。处理器如果发生异常会进入异常处理模式，开始执行由异常的类型决定的特殊代码。
假如有下面一段可执行二进制文件：

```c
	0X000: 6123
	0x00e：7328000000
```

我们要这么把它解析成指令，并了解它在执行过程中每一步是怎么操作的，假如我们的指令集如下左图，寄存器的表示如下右图，我们可以很快知道`6123`指令表示的是`subl %edx %ebx`同理可知`7328000000`是`je done`。

![Alt text](/public/img/technology/ISA-8.png)

知道了具体的指令，下面我们看下subl指令的执行步骤，如下图：

![Alt text](/public/img/technology/ISA-9.png)

从上图我们可以看到一条sub指令在执行时候经过了取值、译码、执行、访存、写回和更新pc各个步骤的具体执行内容。

### 1.4 SEQ的硬件结构
SEQ是 Sequential CPU的实现,表现在指令的执行要依次经历各个阶段(取值->译码->执行->访存->写回->更新PC).下图是SEQ的硬件结构：

![Alt text](/public/img/technology/ISA-10.png)

我们看到1.3中的subl指令的执行赋值是从上往下的顺序执行的，但是上图中硬件结构的操作运行完全不同，一个时钟的变化会引发一个经过组合逻辑的流，来执行整个指令。
<p style="text-indent: 2em">SEQ的实现包含组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件寄存器），随机访问存储器（寄存器文件、指令存储器和数据存储器）。组合逻辑不需要任何时序或控制---只要输入变化了，值就通过逻辑门网络传播。
<p style="text-indent: 2em">程序计数器、条件码寄存器、数据存储器和寄存器文件都是通过一个时钟信号来控制，它触发将新值装到寄存器以及将值写到随机访问存储器。每个时间周期，程序计数器都会装载新的指令地址，所以要控制处理器中的活动的时序，只需要寄存器和存储器的时钟控制。
<p style="text-indent: 2em">如果是一个ret指令需要处理，它需要从更新PC开始，然后从指令处理器中读取指令，从寄存器中读取栈指针，ALU要减小栈指针，还要从存储器中读出返回地址，所有这一起都必须在这个周期结束之前完成，所有SEQ的速度会很慢，我们必须实现流水化，流水线化可以增加系统的吞吐量。

> - 参考书籍
>- 《深入理解计算机系统》作者: Randal E.Bryant / David O'Hallaron 出版社: 中国电力出版社
