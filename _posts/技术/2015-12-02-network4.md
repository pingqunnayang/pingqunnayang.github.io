---
layout: post
title:  计算机网络学习四
titlename: 计算机网络学习四
date:   2015-12-02 14:48:53 
category: 技术
tags: network TCP IP
description:
---
###运输层

<p style="text-indent: 2em">运输层向它上面的应用层提供通讯服务，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层。
两个主机进行通讯就是两个主机中的应用进程相互通信，通信的真正端点并不是主机而是主机中的进程。运输层一个很重要的功能就是`复用（multiplexing）和分用（demuliplexing）`，复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。

运输层两个最主要的协议：

1. 用户数据报协议UDP（User Datagram Protocol）
2. 传输控制协议TCP（Transmission Control Protocol）

`运输层在复用和分用时如何区分要把数据交付给指明的那个应用进程？`

解决这个问题的方法就是在运输层使用协议端口号（protocol port number）或者简称端口(port)，TCP/IP的运输层用一个16位端口号来标志一个端口，允许有65535个不同的端口号，端口号共分为下面几类：

1. 服务器端使用的端口号，0~1023是系统端口号。
2. 登记端口号，数值为1024~49151。
3. 客户端使用的端口号，数值为49152~65535，这类端口仅在客户进程运行时才动态选择，因此又叫做短暂端口号。

### 1. 用户数据报协议UDP
UDP的主要特点是：
1. UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. UDP是面向报文的，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层，UDP对应用层交下来的报文，即不合并，也不拆分，而是保留这些报文的边界。
4. UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。
5. UDP支持一对一、一对多、多对一和多对多的交互通信。
6. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

![Alt text](/public/img/technology/network-18.png)

- 源端口 源端口号。
- 目的端口 目的端口号。
- 长度 UDP用户数据报的长度，其最小值是8。
- 检验和 检查UDP用户数据报在传输中是否出错。

>伪首部并不是UDP用户数据报真正的首部，知识在计算校验和时，临时添加在UDP用户数据报前面。但UDP的检验和是把首部和数据部分一起都校验。

### 2. 传输控制协议TCP概述
TCP最主要的特点：

- TCP是面向连接的运输层协议，应用层在使用TCP协议之前，必须先建立TCP连接。
- 每一条TCP连接只能有两个端点（endpoint），每一条TCP连接只能是点对点的。
- TCP提供`可靠交付`的服务，TCP连接传送的数据无差错、不丢失、不重复、并且按序到达。
- TCP提供全双工通信，TCP连接的两端都设有发送缓冲和接收缓存。在发送时，应用程序在把数据传送给TCP缓存后就可以做自己的事，而TCP在合适的时候把数据发送出去，在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存。
- 面向字节流。TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。

`每一条TCP连接有两个端点，那么TCP连接的端点是什么呢？`

TCP连接的端点叫做套接字（socket）或插口，端口号拼接到IP地址即构成了套接字。

>套接字 socket = （IP地址 ： 端口号）

每一条TCP连接唯一地被通信两端的两个端点所确定。即：

>TCP 连接  ::=  {socket1，socket2} = {(IP1 : port1)，(IP2 : port2)}

同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。

#### 2.1 可靠传输的原理

理想的传输条件有以下两个特点：

- 传输信道不产生差错。
- 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。

<p style="text-indent: 2em">实际网络都不具备以上两个理想条件，但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。

####2.1.1 停止等待发送
<p style="text-indent: 2em">全双工通信的双方即是发送方也是接收方，停止等待就是A发送完一个分组就停止发送，A等待对方B的确认信息，在收到B确认后再发送下一个分组。

`A向B发送数据如果出现差错了怎么办？`

<p style="text-indent: 2em">A只要超过一段时间没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，这就叫做超时重传。实现超时重传需要注意下面三点：

- A发送完一个分组后，必须暂时保留已发送的分组的副本。
- 分组和确认分组必须编号，这样才能明确哪一个发送出去的分钟收到了确认，而哪一个分组还没有收到确认。
- 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。

![Alt text](/public/img/technology/network-19.png)

`B收到了重传的分组这时应该采用什么动作？`

1. 丢弃这个重复的分组，不向上层交付。
2. 向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到B对M1的确认。

使用上面的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议称为"自动重传请求ARQ（Automatic Repeat reQuest）"。
使用停止等待协议的优点是简单，但缺点就是信道的利用率太低，如下图：

![Alt text](/public/img/technology/network-20.png)

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。

![Alt text](/public/img/technology/network-21.png)

当使用流水线传输时，就要使用联系ARQ协议和滑动窗口协议，滑动窗口协议比较复杂，是TCP协议的精髓所在。

#### 2.2 TCP报文段的首部格式

![Alt text](/public/img/technology/network-22.png)

- **源端口和目的端口**
- **序号** 占4个字节，序号增加到2^32-1后，下一个序号又回到0，序号是指本报文段所发送的数据的第一个字节的序号。
- **确认号** 是期望收到对方下一个报文的第一个数据字节的序号，用在确认报文中。

>若确认号为N，则表明到序号N-1为止的所有数据都已正确收到。

- **数据偏移**是指TCP报文段的首部长度。
- **保留** 保留到以后使用。
- **紧急URG**当URG=1时标明紧急指针字段有效，它告诉系统此报文段有紧急数据，不要按原来的排队顺序来传送，应该尽快传送。
- **确认ACK**仅当ACK=1时确认字段才有效，连接建立后所有传送的报文段必须把ACK置为1。
- **推送PUSH**当两个进程进行通信，有时候一端应用进程希望在键入一个命令后立即能够收到对方的响应，这种情况TCP就可以使用PUSH=1，接收方收到PUSH=1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
- **复位RST** 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。
- **同步SYN（synchronization）** 当SYN=1而ACK=0时，表明这是一个连接请求报文段。
- **终止FIN** 用来释放一个连接，当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
- **窗口** 窗口指的是发送本报文段的一方的接收窗口，窗口值告诉对方，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。

>窗口字段明确指出了现在允许对方发送的数据量，窗口值是经常在动态变化着。`

- **检验和** 检验的范围包括首部和数据这两部分。
- **紧急指针** 紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数。
- **选项** 长度可变，最长可达40字节。

#### 2.3 TCP可靠传输实现
#### 2.3.1 以字节为单位的滑动窗口
凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。

![Alt text](/public/img/technology/network-23.png)

我们用三个指针描述一个发送窗口的状态，P1、P2、P3这三个指针指向的几个部分意义如下：

P3 - P1 = A的发送窗口

P2 - P1 = 已发送但尚未收到确认的字节数

P3 - P2 = 允许发送但尚未发送的字节数

B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31（即期望收到的序号）而不能是32或33。

#### 2.3.2 超时重传时间的选择

<p style="text-indent: 2em">TCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认时间，这两个时间之差就是报文段的往返时间RTT，TCP保留了RTT的一个加权平均往返时间RTTS，按下面公式计算下一次RTTS.

![Alt text](/public/img/technology/network-24.png)

>超时重传时间RRO=RTTS + 4 * RTTD

RRTD是RTT的偏差的加权平均值，它与RTTS和新的RTT样本之差有关。

![Alt text](/public/img/technology/network-25.png)

`如何判断此确认报文段是对先发送的报文段确认，还是对后来重传的报文段的确认？`

<p style="text-indent: 2em">由于重传的报文段和原来的报文段完全一样，因此源主机在收到确认后，无法做出正确的判断，而正确的判断对加权平均RTTS的值关系比较大，如果收到的确认是对重传报文段的确认，但被当做源主机原来报文的确认，那么计算RTTS和超时重传时间RTO就会偏大，相反RTO会偏小。
<p style="text-indent: 2em">解决方案是在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本，这样得出的加权平均RTTS和RTO就较准确。如果这样，那么超时重传时间RDO就无法更新，所有Karn提出一个新的方法，报文段每重传一次，就把超时重传时间RTO增大有些，典型的做法是取新的重传时间为2倍的旧的重传时间。

#### 2.3.3 选择确认SACK

`如果收到的报文段无差错，只是未按序号，中间缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？`

TCP报文段首部中增加SACK选项，以便报告收到不连续的字节块的边界。

#### 2.4 TCP流量控制
<p style="text-indent: 2em">所谓流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。设A向B发送数据，在连接建立时，B告诉A："我的接收窗口rwnd=400"（这里rwnd表示receiver window），因此发送方的发送窗口不能超过接收方给出的接收窗口的数值，TCP的窗口单位是字节，不是报文段。

![Alt text](/public/img/technology/network-26.png)

`B向A发送了零窗口后不久，B的接收缓存又有了一些存储空间，于是B向A发送rwnd=400的报文段，如果报文丢失了，A一直等待收到B发送的非零窗口通知，而B也一直等待A发送的数据，如果没有其他措施，就会导致死锁局面一直延续下去，如何解决？`

<p style="text-indent: 2em">TCP为每一个连接设有一个持续计时器（persistence timer），只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文端。
应用程序把数据传送到TCP的发送缓存后，剩下的发送任务就由TCP来控制了，可以使用不同的机制来控制TCP报文段的发送时机，例如下面：

1. TCP维持一个变量，它等于最大报文段长度MSS。
2. 发送方的应用进程指明要求发送的报文段，即TCP支持推送（push）操作。
3. 发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段。

<p style="text-indent: 2em">TCP的实现中广泛使用Nagle算法，算法如下：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节缓存起来。当发送方收到对第一个数据字符确认后，再把发送缓冲中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。

####2.5 TCP的拥塞控制
所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
常用的控制拥塞方法有慢开始、拥塞避免、快重传和快恢复。

####2.6 TCP运输连接管理
TCP连接建立过程中要解决以下三个问题：

1. 要使每一方能够确知对方的存在。
2. 要允许双方协商一些参数（如最大窗口值、时间戳选项以及服务质量等）。
3. 能够对运输实体资源（如缓冲大小，连接表中的项目等）进行分配。

####2.6.1 TCP的连接建立

![Alt text](/public/img/technology/network-27.png)

`此过程是三次握手，为什么要进行三次握手？`

<p style="text-indent: 2em">如果只进行2次握手，那么有一种情况A发出请求，但因连接请求报文丢失而未收到确认，A再重传一次连接请求，后来收到了确认，建立了连接。假如现在A发出的第一个请求报文段并没有丢失，知识在网络节点长时间滞留了，B收到失效的连接后，就误以为A有发出一次新的连接请求，于是向A发送确认报文，同意建立连接，假定不采用三次握手，那么只要B发出确认，新的连接就建立了。

####2.6.2 TCP的连接释放

![Alt text](/public/img/technology/network-28.png)

<p style="text-indent: 2em">B进入的CLOSE-WAIT状态，TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。A收到B的确认后，就进入FIN-WAIT-2状态，等待B发出的连接释放报文段。若B已经没有向A发送的数据，其应用进程就通知TCP释放连接，这时B发出的连接释放报文必须使FIN=1，这是B进入LAST-ACK状态，等待A的确认。A在收到B的连接释放报文后，进入TIME-WAIT状态。

`为什么A在TIME-WAIT状态必须等待2MSL的时间？`

第一，为了保证A发送的最后一个ACK报文段能够到达B。<br>
第二，防止"已失效的连接请求报文段"，可以使本连接持续的时间内所产生的所有报文段都从网络中消失。










    



